# 分布式基础理论

## 分布式理论

### CAP

一致性（Consisency）：代表数据在**任何时刻、任何分布式节点**中所看到的都是**符合预期**的。

可用性（Avaliability）：代表系统**不间断地**提升服务的能力。

分区容忍性（Partition Tolerance）：代表分布式环境中部分节点因网络原因而彼此失联后，即与其他节点**形成“网络分区”**时，系统仍能**正确地提供服务**的能力。

> 一个分布式系统中，涉及共享数据问题时，上述的三个特性最多只能同时满足其中两个。

### 案例释义

![cap1](http://img.javalemon.com/typora/cap1.svg)

假设用户余额共1500元，当用户购买一瓶茅台时，余额支付了1499元、茅台库存减1、履约开始准备派单。

- 此时下单余额节点2操作账号减少1499，需同步信息至另外2个节点，如果同步期间 用户再次尝试下单请求分发至余额节点1，判断余额充足，可继续下单，则会出现一致性问题。

- 如果由于要把用户的余额数据同步至其他节点，此时需停用此用户余额相关的服务，直至数据一致后方可恢复，这将导致用户再次期间无法正常使用，此为可用性问题。（如果是库存节点则更为严重，可能导致整个促销活动库存不可用）

- 如果此时余额节点3因网络问题，无法与其他节点同步（无法正常的进行节点变动信息交换），此时服务集群无论哪一部分节点对外提供的服务都可能是不正确的。整个集群不能承受由于部分节点之间的链接中断而不能正确提供服务此为分区容忍性问题。

### 基于CAP的系统归类

- CA系统

舍弃分区容忍性，认为各节点之间的通信是可靠的或者通信方式可以用别的手段进行。

比如：传统的关系型数据库，Oracle的RAC集群，数据不是通过网络进行共享的，而是采用共享存储中的同一份数据文件，通过共享磁盘的方式来避免出现网络分区，严格意义上来讲，RAC集群并不能称作分布式数据库。

- CP系统

舍弃可用性，认为系统之间同步信息时间可以忽略或者所需要的时间可以无限制的延长。

比如：HBase，加入某个RegionServer宕机了，这个RegionServer所持有的键值范围都将下线，直到数据恢复过程完成为止。再比如单一系统的多数据源问题，采用2PC/3PC （phase commit）2阶段或者3阶段提交模式，来保障可用性，同时满足了分区容忍性和一致性。

- AP系统

舍弃一致性，认为各节点之间提供的数据服务是一致的或者可接受出现不一致的情况。

比如：永远可靠的通信在分布式系统中是不成立的，可用性也是分布式系统的设计初衷（高可用、高性能），所以目前大部分的分布式系统都是AP系统，至于一致性的问题，一般采用最终一致性解决，以及接口的幂等性设计。

### BASE

Base Avaliable（基本可用）

Soft State（柔性事务）

Eventually Consistent（最终一致性）

## AP系统的一致性保障（分布式事务）

> 先从XA说起：并不是Java的技术规范，而是一套与语言无关的通用规范。核心内容是处理事务的架构，定义了全局的事务管理器和局部的资源管理器（主要用于驱动本地事务）之间的通信接口。例如Java版本的JTA。

### 两段式提交（2PC）

![cap2](http://img.javalemon.com/typora/cap2.svg)

### 三段式提交（3PC）

![cap3](http://img.javalemon.com/typora/cap3.svg)

关于2PC和3PC讲解比较详细，可参见：https://blog.csdn.net/qq_31960623/article/details/116429261

2PC/3PC提供了解决数据一致性的方案，但仍会出现不一致的情况，比如协调者宕机的case。

典型的二阶段提交：rocketMq事务消息的[处理流程](https://help.aliyun.com/document_detail/43348.html)

![img](http://img.javalemon.com/typora/p365949.png)

### 可靠事件队列

最大努力交付（Best-Effort Delivery）

![cap4](http://img.javalemon.com/typora/cap4.svg)

### TCC事务

与2PC的区别是：TCC不是基础设施层面，在用户代码层面，灵活度比较高，可以根据需要设计资源锁定的粒度。

TCC: try confirm cacel

![cap5](http://img.javalemon.com/typora/cap5.svg)

### SAGA事务

> 将一个大事务分解为可以交错运行的一系列子事务集合。

1. 将大事务拆分成若干个小事务，比如将事务T拆分为T1、T2.....Tn。

1. 为每一个小事务Tx设置对应的补偿动作 比如：C1、C2.....Cn

举例说明：比如下单时用户勾选无货退款，就是对已支付成功但是无法履约的补偿动作。

如果事务失败则有两种处理方式：正向或者逆向，比如正向的找供应商补库存，逆向的退款。

对比TCC事务，无需对资源进行冻结此类操作，降低编码难度。
